mod desc;
mod jvm_impl;
mod op;
mod parse;
mod stdlib;

use std::{collections::HashMap, rc::Rc};

pub use op::next_op;
pub use stdlib::load_core as stdlib_load_core;

pub struct JVM {
    classes: HashMap<String, Rc<JClass>>,
    class_rt: HashMap<String, JClassRuntimeInfo>,
}

#[derive(Debug)]
pub struct JThreadContext {
    stack: Vec<JValue>,
    frames: Vec<JStackFrame>,
}

impl JThreadContext {
    pub const DEFAULT_STACK: usize = 1024;
    pub const MAX_STACK: usize = 1024;
    pub const DEFAULT_FRAME: usize = Self::DEFAULT_STACK / 8;
}

impl Default for JThreadContext {
    fn default() -> Self {
        Self {
            stack: Vec::with_capacity(Self::DEFAULT_STACK),
            frames: Vec::with_capacity(Self::DEFAULT_FRAME),
        }
    }
}

#[derive(Debug)]
struct JStackFrame {
    bp: u32,
    stack: u32,
    local: u32,
    pc: u32,
    class: Rc<JClass>,
    method: Rc<MethodInfo>,
}

#[derive(Debug, Clone)]
pub enum JValue {
    Invalid,
    Null,
    Int(i32),
    Long(i64),
    Float(f32),
    Double(f64),
    //Ref(Rc<JValue>),
}

#[derive(Debug, PartialEq, Eq)]
struct JType {
    array_dim: usize,
    ctype: JComponentType,
}

impl JType {
    fn scalar_of(ctype: JComponentType) -> Self {
        Self {
            array_dim: 0,
            ctype,
        }
    }
    fn array_of(ctype: JComponentType, array_dim: usize) -> Self {
        Self { array_dim, ctype }
    }

    pub fn to_default_value(&self) -> JValue {
        if self.array_dim > 0 {
            JValue::Null
        } else {
            self.ctype.to_default_value()
        }
    }
}

#[derive(Debug, PartialEq, Eq)]
enum JComponentType {
    Boolean,
    Byte,
    Char,
    Short,
    Int,
    Long,
    Float,
    Double,
    Object(String),
}

impl JComponentType {
    pub fn to_default_value(&self) -> JValue {
        match self {
            Self::Boolean | Self::Byte | Self::Char | Self::Short | Self::Int => JValue::Int(0),
            Self::Long => JValue::Long(0),
            Self::Float => JValue::Float(0.0),
            Self::Double => JValue::Double(0.0),
            Self::Object(_) => JValue::Null,
        }
    }
}

#[allow(dead_code)]
pub mod acc_class {
    /// Declared public; may be accessed from outside its package.
    pub const PUBLIC: u16 = 0x0001;
    /// Declared final; no subclasses allowed.
    pub const FINAL: u16 = 0x0010;
    /// Treat superclass methods specially when invoked by the invokespecial instruction.
    pub const SUPER: u16 = 0x0020;
    /// Is an interface, not a class.
    pub const INTERFACE: u16 = 0x0200;
    /// Declared abstract; must not be instantiated.
    pub const ABSTRACT: u16 = 0x0400;
    /// Declared synthetic; not present in the source code.
    pub const SYNTHETIC: u16 = 0x1000;
    /// Declared as an annotation type.
    pub const ANNOTATION: u16 = 0x2000;
    /// Declared as a class that is not intended to be instantiated.
    pub const ENUM: u16 = 0x4000;
}

#[allow(dead_code)]
pub mod acc_field {
    /// Declared public; may be accessed from outside its package.
    pub const PUBLIC: u16 = 0x0001;
    /// Declared private; usable only within the defining class.
    pub const PRIVATE: u16 = 0x0002;
    /// Declared protected; may be accessed within subclasses.
    pub const PROTECTED: u16 = 0x0004;
    /// Declared static.
    pub const STATIC: u16 = 0x0008;
    /// Declared final; never directly assigned to after object construction (JLS ยง17.5).
    pub const FINAL: u16 = 0x0010;
    /// Declared volatile; cannot be cached.
    pub const VOLATILE: u16 = 0x0040;
    /// Declared transient; not written or read by a persistent object manager.
    pub const TRANSIENT: u16 = 0x0080;
    /// Declared synthetic; not present in the source code.
    pub const SYNTHETIC: u16 = 0x1000;
    /// Declared as an element of an enum.
    pub const ENUM: u16 = 0x4000;
}

#[allow(dead_code)]
pub mod acc_method {
    /// Declared public; may be accessed from outside its package.
    pub const PUBLIC: u16 = 0x0001;
    /// Declared private; accessible only within the defining class.
    pub const PRIVATE: u16 = 0x0002;
    /// Declared protected; may be accessed within subclasses.
    pub const PROTECTED: u16 = 0x0004;
    /// Declared static.
    pub const STATIC: u16 = 0x0008;
    /// Declared final; may not be overridden.
    pub const FINAL: u16 = 0x0010;
    /// Declared synchronized; invocation is wrapped by a monitor use.
    pub const SYNCHRONIZED: u16 = 0x0020;
    /// A bridge method, generated by the compiler.
    pub const BRIDGE: u16 = 0x0040;
    /// Declared with variable number of arguments.
    pub const VARARGS: u16 = 0x0080;
    /// Declared native; implemented in a language other than Java.
    pub const NATIVE: u16 = 0x0100;
    /// Declared abstract; no implementation is provided.
    pub const ABSTRACT: u16 = 0x0400;
    /// Declared strictfp; floating-point mode is FP-strict
    pub const STRICT: u16 = 0x0800;
    /// Declared synthetic; not present in the source code.
    pub const SYNTHETIC: u16 = 0x1000;
}

#[allow(dead_code)]
#[derive(Debug)]
pub struct JClass {
    constant_pool: ConstantPool,
    access_flags: u16,
    this_class: Rc<String>,
    super_class: Option<Rc<String>>,
    interfaces: Vec<Rc<String>>,
    fields: HashMap<String, Rc<FieldInfo>>,
    methods: HashMap<String, Rc<MethodInfo>>,
    // attributes
}

#[derive(Default)]
struct JClassRuntimeInfo {
    pub initialized: bool,
    pub static_fields: HashMap<String, JValue>,
}

#[derive(Debug)]
struct ConstantPool {
    pool: Vec<ConstInfo>,
}

#[derive(Debug, Clone)]
enum ConstInfo {
    None,
    Class {
        name: Rc<String>,
    },
    Fieldref {
        class: Rc<String>,
        name: Rc<String>,
        descriptor: Rc<String>,
    },
    Methodref {
        class: Rc<String>,
        name: Rc<String>,
        descriptor: Rc<String>,
    },
    InterfaceMethodref {
        class: Rc<String>,
        name: Rc<String>,
        descriptor: Rc<String>,
    },
    String {
        string: Rc<String>,
    },
    Integer {
        bytes: i32,
    },
    Float {
        bytes: f32,
    },
    Long {
        bytes: i64,
    },
    Double {
        bytes: f64,
    },
    NameAndType {
        name: Rc<String>,
        descriptor: Rc<String>,
    },
    Utf8 {
        bytes: Rc<String>,
    },
}

#[derive(Debug)]
pub struct FieldInfo {
    access_flags: u16,
    name: Rc<String>,
    descriptor: Rc<String>,
    name_desc: String,
    // attributes
    constant_value: Option<JValue>,

    // parsed
    pub jtype: JType,
}

type NativeFunc = Box<dyn FnMut(/* TODO */)>;

enum MethodCode {
    /// No code attribute
    None,
    /// JVM instructions
    JOp(Code),
    /// Native function call
    Native(NativeFunc),
}

impl std::fmt::Debug for MethodCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        match self {
            Self::None => f.write_str("None"),
            Self::JOp(code) => f.debug_tuple("JOp").field(code).finish(),
            Self::Native(_) => f.write_str("Native"),
        }
    }
}

#[derive(Debug)]
pub struct MethodInfo {
    access_flags: u16,
    name: Rc<String>,
    descriptor: Rc<String>,
    name_desc: String,
    // attributes
    pub code: Option<Code>,

    // parsed
    pub ret_type: Option<JType>,
    pub param_types: Vec<JType>,
}

#[derive(Debug)]
enum Attribute {
    ConstantValue(JValue),
    Code(Code),
}

pub struct Code {
    pub max_stack: u16,
    pub max_locals: u16,
    pub code: Vec<u8>,
    pub exception_table: Vec<ExceptionTableEntry>,
    // attributes
}

impl std::fmt::Debug for Code {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Code")
            .field("max_stack", &self.max_stack)
            .field("max_locals", &self.max_locals)
            .field("code_len", &self.code.len())
            .field("exception_table", &self.exception_table)
            .finish()
    }
}

#[derive(Debug, Clone, Copy)]
pub struct ExceptionTableEntry {
    pub start_pc: u16,
    pub end_pc: u16,
    pub handler_pc: u16,
    pub catch_type: u16,
}
